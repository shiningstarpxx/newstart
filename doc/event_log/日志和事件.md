



> 加入linked in的时候，正好赶上重构单体化，中心化的数据库，要变成分布式的系统。最终构建了成了图数据库，一个分布式的检索后端服务，和一个key-value的存储
>
> 构建这些的核心思想：日志。更具体的说是，write ahead log （WAL）或者是traction log。日志有着悠久的历史，是许多分布式系统和实时应用结构的核心。
>
> 如果不懂log，无法理解databases, NoSQL stores, key value stores, replication, paxos, hadoop, version control, or almost any software system 。 本文会介绍log，**what is log and how to use logs for data integration, real time processing, and system building.**
>
> *** Part One: What is Log ***
>
> A log is perhaps the simplest possible storage abstraction. It is an append-only, totally-ordered sequence of records ordered by time. It looks like this:
>
> ![](https://content.linkedin.com/content/dam/engineering/en-us/blog/migrated/log.png)
>
> Records are appended to the end of the log, and reads proceed left-to-right. Each entry is assigned a unique sequential log entry number.
>
> The ordering of records defines a notion of "time" since entries to the left are defined to be older then entries to the right（事实上，上面这句话不一定对）. The log entry number can be thought of as the "timestamp" of the entry. Describing this ordering as a notion of time seems a bit odd at first, but it has the convenient property that it is decoupled from any particular physical clock. This property will turn out to be essential as we get to distributed systems. (序列等价于timestamp)
>
> The contents and format of the records aren't important for the purposes of this discussion. Also, we can't just keep adding records to the log as we'll eventually run out of space. I'll come back to this in a bit. (日志的内容和格式不在讨论范围内)
>
> So, a log is not all that different from a file or a table. A file is an array of bytes, a table is an array of records, and a log is really just a kind of table or file where the records are sorted by time. （文件是bytes的数组，table是records的数组，log跟table和文件类似，只是记录按时间排序了）
>
> At this point you might be wondering why it is worth talking about something so simple? How is a append-only sequence of records in any way related to data systems? The answer is that logs have a specific purpose: they record what happened and when. For distributed data systems this is, in many ways, the very heart of the problem （日志记录了何时发生，且发生了什么，对分布式系统来说，这就是核心 -- 原则上没有GST，这个也不是很准确）
>
> -But before we get too far let me clarify something that is a bit confusing. Every programmer is familiar with another definition of logging—the unstructured error messages or trace info an application might write out to a local file using syslog or log4j. For clarity I will call this "application logging". The application log is a degenerative form of the log concept I am describing. The biggest difference is that text logs are meant to be primarily for humans to read and the "journal" or "data logs" I'm describing are built for programmatic access. （应用日志用于给人读，而“journal”或者“data logs”用来构建系统）
>
> (Actually, if you think about it, the idea of humans reading through logs on individual machines is something of an anachronism. This approach quickly becomes an unmanageable strategy when many services and servers are involved and the purpose of logs quickly becomes as an input to queries and graphs to understand behavior across many machines—something for which english text in files is not nearly as appropriate as the kind structured log described here.) （单机或许可读，集群将无法处理，需要查询或者图来理解--也就是说文本比不上结构化）
>
> **Log In Database**
>
> I don't know where the log concept originated—probably it is one of those things like binary search that is too simple for the inventor to realize it was an invention. It is present as early as IBM's [System R](http://www.cs.berkeley.edu/~brewer/cs262/SystemR.pdf). The usage in databases has to do with keeping in sync the variety of data structures and indexes in the presence of crashes. To make this atomic and durable, a database uses a log to write out information about the records they will be modifying, before applying the changes to all the various data structures it maintains. The log is the record of what happened, and each table or index is a projection of this history into some useful data structure or index. Since the log is immediately persisted it is used as the authoritative source in restoring all other persistent structures in the event of a crash. (日志在IBM的System R中出现，主要是在crash时，来保持索引和各种数据结构的同步。为了保证原子化和持久化， 数据库先写日志，然后再做更改，log描述了发生了什么。因为日志会立刻持久化，在crash后，它就会作为最有权威的数据源)
>
> Over-time the usage of the log grew from an implementation detail of ACID to a method for replicating data between databases. It turns out that the sequence of changes that happened on the database is exactly what is needed to keep a remote replica database in sync. Oracle, MySQL, and PostgreSQL include log shipping protocols to transmit portions of log to replica databases which act as slaves. Oracle has productized the log as a general data subscription mechanism for non-oracle data subscribers with their [XStreams](http://docs.oracle.com/cd/E11882_01/server.112/e16545/xstrm_intro.htm) and [GoldenGate](http://www.oracle.com/technetwork/middleware/goldengate/overview/index.html) and similar facilities in MySQL and PostgreSQL are key components of many data architectures. （日志一开始是ACID的实现细节，后来发展成为了replication的细节。Oracle， MySQl， PGSQL都用来实现replica，同时还提供了数据订阅data subscription为异构数据源）
>
> Because of this origin, the concept of a machine readable log has largely been confined to database internals. The use of logs as a mechanism for data subscription seems to have arisen almost by chance. But this very abstraction is ideal for supporting all kinds of messaging, data flow, and real-time data processing. （日志的这种抽象，很适合支持其他消息类型，类似数据流，实时数据处理）
>
> **Log in Distributed System**
>
> 

#### Reference

1. [The Log: What every software engineer should know about real-time data's unifying abstraction](https://engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying)

